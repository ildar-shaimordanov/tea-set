#! ~/.bash/functions-misc

# =========================================================================

symlink() {
	[ $# -eq 2 ] || {
		echo "Make symbolic links in the Cygwin 1.7.xx style"
		echo "Usage: symlink TARGET LINK_NAME"
		return 1
	}
	printf '!<symlink>%s\0' "$1" > "$2" || return $?
	chattr +s "$2"
}

# =========================================================================

# Manage with windows clipboard

clp() {
	if [ "$1" = "-h" -o "$1" = "--help" ]
	then
		cat <<-HELP
		Usage: [ clp | ] ... [ | clp ]

		Copy data from and/or to the clipboard
		HELP
		return
	fi

	if [ ! -t 0 ]
	then
		# ... | clp
		cat - >/dev/clipboard
	else
		# clip | ...
		# or simply output data from the clipboard
		cat - </dev/clipboard
	fi
}

# =========================================================================

# https://github.com/rprichard/winpty

if ! which winpty > /dev/null 2>&1
then
	# Assume winpty* instances lie next to Cygwin/Msys separately
	# under their own directories as follows:
	# -- CYGROOT/../winpty*cygwin* for Cygwin
	# -- MSYSROOT/../winpty*msys2* for Msys

	case "$( uname | tr [:upper:] [:lower:] )" in
	cygwin* )
		WINPTY="$(
			ls -rd $( cygpath -m / )/../winpty*cygwin* \
			| head -1 \
			| xargs -r cygpath
		)"
		;;
	msys* | mingw* | windows* )
		WINPTY="$(
			ls -d "$( cd / ; pwd -W )"/../winpty*msys2* \
			| head -1 \
			| xargs -r -IX bash -c 'cd "X" && pwd' 2>/dev/null
		)"
		;;
	esac

	if [ -n "$WINPTY" -a -x "$WINPTY/bin/winpty" ]
	then
		PATH="$PATH:$WINPTY/bin"
	fi

	unset WINPTY
fi

# =========================================================================

# Native Windows application invoker (works in most cases)

alias np='call notepad'

call() {
	eval set -- "$1" $( [ $# -gt 1 ] && cygpath -m -- "${@:2}" | sed 's/^\|$/"/g' )
	command "$@"
}

# =========================================================================

# pwd -W for cygwin
uname | grep -iq cygwin && pwd() {
	case "$1" in
	-W )
		cygpath -m "$PWD"
		;;
	* )
		builtin pwd "$@"
		;;
	esac
}

# =========================================================================

# join lines

j2() {
	sed "N;s/\n/$1/"
}

j3() {
	sed "N;N;s/\n/$1/g"
}

jn() {
	sed ":a;N;s/\n/$1/;ta"
}

# =========================================================================

ip2hex() {
	local ip
	IFS="." read -ra ip <<<"$1"
	printf "0x0001%02x%02x%02x%02x" "${ip[@]}"
}

hex2ip() {
	printf "%d.%d.%d.%d" "0x${1:6:2}" "0x${1:8:2}" "0x${1:10:2}" "0x${1:12:2}"
}

# =========================================================================

image2pdf() {
	convert -adjoin -format pdf "$@"
}

img2pdf() {
	jpegtopnm "${1:--}" | pnmtops -noturn | ps2pdf - "${2:--}"
}

cover2folder() {
	local resize="300x300>"
	local gravity=""
	local crop=""

	case "$1" in
	-l | -r )
		resize="600x300>"
		crop="50%x100%"

		case "$1" in
		-l ) gravity="west" ;;
		-r ) gravity="east" ;;
		esac

		shift
		;;
	-u | -d )
		resize="300x600>"
		crop="100%x50%"

		case "$1" in
		-u ) gravity="north" ;;
		-d ) gravity="south" ;;
		esac

		shift
		;;
	esac

	convert "${1:-cover-front.jpg}" \
		-resize "$resize" \
		${gravity:+-gravity "$gravity"} \
		${crop:+-crop "$crop"} \
		"folder.jpg"
}

# =========================================================================

# POSIX shell calculator
# https://www.commandlinefu.com/commands/view/24415/shell-pocket-calculator-pure-sh

calc() {
	printf "%.8g\n" "$( printf "%s\n" "$*" | bc -l )"
}

# =========================================================================

# Additional function, complementary to "declare -p", but shorter in
# typing and produces more convenient output
var() {
	[ "$1" = "-r" ] && {
		unset VAR_OPTS
		return
	}

	[ $# -eq 0 -a -n "$VAR_OPTS" ] && {
		$FUNCNAME $VAR_OPTS
		return $?
	}

	[ $# -eq 0 -o "$1" == "-h" ] && {
		echo "Usage: $FUNCNAME [ -h | -r | [-m] [-l] name ... ]" >&2
		return 1
	}

	VAR_OPTS="$@"

	local mark	# mark output?
	local len	# print length?

	local arr	# array or assoc

	local n1	# outer index
	local n2	# inner index

	local si	# string for parsed length
	local sv	# string for parsed values or indexes

	[ "$1" == "-m" ] && {
		mark=1
		shift
	}

	[ "$1" == "-l" ] && {
		len=1
		shift
	}

	[ -n "$mark" ] && echo "#### VAR BEGIN"

	for n1 in "$@"
	do
		case "$( declare -p "$n1" 2>/dev/null )" in
		''		) echo "$n1: not found" ; continue ;;
		'declare -a'*	) arr="array" ;;
		'declare -A'*	) arr="assoc" ;;
		*		) arr="" ;;
		esac

		[ -n "$arr" ] || {
			eval si="\${#$n1}"
			eval sv="\${$n1}"
			printf -- "%s%s = %s\n" "$n1" "${len:+:$si}" "$sv"
			continue
		}

		eval si="\${#$n1[@]}"
		eval sv="\${!$n1[@]}"
		printf -- "%s: %s(%s)\n" "$n1" "$arr" "$si"

		for n2 in $sv
		do
			eval si="\${#$n1[$n2]}"
			eval sv="\${$n1[$n2]}"
			printf -- " [%s%s] = %s\n" "$n2" "${len:+:$si}" "$sv"
		done
	done

	[ -n "$mark" ] && echo "#### VAR END"
}

# =========================================================================

# EOF
